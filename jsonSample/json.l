%{
// Generated by Bison
#include "json.tab.h"
%}

%option noyywrap

%x EXPECT_STRING

DIGIT	[0-9]

QUOTE		["]
NOTQUOTE	[^"]

%%

	/*
	Putting the EXPECT_STRING rules above everything else makes sure that the
	lexer will prioritize our string rules over everything else.
	*/
{QUOTE}						BEGIN(EXPECT_STRING);
<EXPECT_STRING>{NOTQUOTE}*	{ yylval.STRING_LITERAL = new std::string(yytext); return STRING_LITERAL; }
<EXPECT_STRING>{QUOTE}		BEGIN(INITIAL);

[ \t\r\n]+	{ /* Whitespace - ignore */ }

	/*
	For each of our token types, we assign yylval to something, and return the
	token type. Returning the token type lets Bison know what kind of token it
	found, and setting yylval lets us access the semantic value of the token
	from the parser actions.
	*/
{DIGIT}+|{DIGIT}*\.{DIGIT}+	{ yylval.NUMBER_LITERAL = new std::string(yytext); return NUMBER_LITERAL; }
true|false					{ yylval.BOOLEAN_LITERAL = new std::string(yytext); return BOOLEAN_LITERAL; }
null						{ yylval.NULL_LITERAL = new std::string(yytext); return NULL_LITERAL; }

	/*
	In regex, '.' is a catch-all character - it will match any single char.
	We can use this to make a final lexer rule that will always be able to match.

	The action's a bit weird - instead of defining a different constant value
	for each character, we can define them all according to their ASCII value.
	This lets us use single-character literals as tokens in Bison! Check json.y
	to see how single-character literals can be used in the parser rules.

	What we're doing here is casting the first (and only) character of
	yytext to an int, and returning that - it gives us the character's ASCII
	value.
	*/
.	return (int) yytext[0];
