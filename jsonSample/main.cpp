// Generated by Bison
#include "json.tab.h"
#include "json_util.h"

#include <algorithm>

/*
A variable that will be written to from the parser.
*/
object_t parser_result;

object_t make_simple_object(std::string* data) {
	object_t res;
	res.is_composite = false;
	res.children = NULL;
	res.data = data;
	return res;
}

object_t make_composite_object(std::vector<keyval_t>* children) {
	object_t res;
	res.is_composite = true;
	res.children = children;
	res.data = NULL;
	return res;
}

keyval_t make_keyval(std::string* key, object_t value) {
	keyval_t res;
	res.key = key;
	res.value = value;
	return res;
}

/*
Once we have a completely parsed JSON object, we can do something with it. I'm
lazy so I'm just finding the nestedness (max depth) of the object, but obviously
you can do something more complex with it, like parse the data to find a specific
key, etc.
*/
int nestedness(object_t object) {
	if (!object.is_composite) return 0;

	int ans = 0;
	for (keyval_t keyval : *object.children) {
		ans = std::max(ans, 1 + nestedness(keyval.value));
	}

	return ans;
}

/*
A simple (a.k.a. incomplete) JSON validator.
Made as an example to show how to use flex and bison.
*/
int main() {
	// Just calls yyparse once.
	// Obviously, you might want to do something more complex here.
	int ret = yyparse();
	if (ret == 0) {
		printf("Max depth of the object: %d\n", nestedness(parser_result));
	}
}
